// middleware_test.go - HTTP Middleware Unit Tests
//
// This file contains unit tests for HTTP middleware components including
// authentication, authorization, and rate limiting.
//
// # Test Coverage
//
// The tests cover the following middleware:
//   - Auth: JWT token validation and user context extraction
//   - RequireRole: Role-based access control
//   - RateLimit: Request rate limiting per client IP
//   - Context helpers: GetUserID, GetUserEmail, GetUserRole
//
// # Security Testing
//
// Tests verify proper handling of various attack vectors including expired
// tokens, invalid signatures, missing headers, and malformed authorization.
//
// Generated by TelemetryFlow RESTful API Generator
// Copyright (c) 2024-2026 DevOpsCorner Indonesia. All rights reserved.
package infrastructure

import (
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/telemetryflow/order-service/internal/infrastructure/config"
	"github.com/telemetryflow/order-service/internal/infrastructure/http/middleware"
)

// =============================================================================
// JWT Authentication Middleware Tests
//
// Tests for JWT-based authentication middleware that validates tokens and
// extracts user information into the request context.
// =============================================================================

// createTestToken is a helper function to generate JWT tokens for testing.
func createTestToken(secret string, claims *middleware.JWTClaims) string {
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, _ := token.SignedString([]byte(secret))
	return tokenString
}

func TestAuth_ValidToken(t *testing.T) {
	e := echo.New()
	jwtConfig := config.JWTConfig{
		Secret:     "test-secret-key",
		Expiration: time.Hour,
	}

	claims := &middleware.JWTClaims{
		UserID: "user-123",
		Email:  "test@example.com",
		Role:   "admin",
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}
	token := createTestToken(jwtConfig.Secret, claims)

	req := httptest.NewRequest(http.MethodGet, "/", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	handler := middleware.Auth(jwtConfig)(func(c echo.Context) error {
		return c.String(http.StatusOK, "success")
	})

	err := handler(c)

	assert.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)
	assert.Equal(t, "user-123", c.Get("user_id"))
	assert.Equal(t, "test@example.com", c.Get("email"))
	assert.Equal(t, "admin", c.Get("role"))
}

func TestAuth_MissingAuthorizationHeader(t *testing.T) {
	e := echo.New()
	jwtConfig := config.JWTConfig{
		Secret: "test-secret-key",
	}

	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	handler := middleware.Auth(jwtConfig)(func(c echo.Context) error {
		return c.String(http.StatusOK, "success")
	})

	err := handler(c)

	require.Error(t, err)
	httpErr, ok := err.(*echo.HTTPError)
	require.True(t, ok)
	assert.Equal(t, http.StatusUnauthorized, httpErr.Code)
	assert.Contains(t, httpErr.Message, "missing authorization header")
}

func TestAuth_InvalidAuthorizationFormat(t *testing.T) {
	tests := []struct {
		name       string
		authHeader string
	}{
		{
			name:       "missing Bearer prefix",
			authHeader: "some-token",
		},
		{
			name:       "wrong prefix",
			authHeader: "Basic some-token",
		},
		{
			name:       "empty token",
			authHeader: "Bearer ",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			jwtConfig := config.JWTConfig{
				Secret: "test-secret-key",
			}

			req := httptest.NewRequest(http.MethodGet, "/", nil)
			req.Header.Set("Authorization", tt.authHeader)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			handler := middleware.Auth(jwtConfig)(func(c echo.Context) error {
				return c.String(http.StatusOK, "success")
			})

			err := handler(c)

			require.Error(t, err)
			httpErr, ok := err.(*echo.HTTPError)
			require.True(t, ok)
			assert.Equal(t, http.StatusUnauthorized, httpErr.Code)
		})
	}
}

func TestAuth_ExpiredToken(t *testing.T) {
	e := echo.New()
	jwtConfig := config.JWTConfig{
		Secret: "test-secret-key",
	}

	claims := &middleware.JWTClaims{
		UserID: "user-123",
		Email:  "test@example.com",
		Role:   "admin",
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(-time.Hour)), // Expired
			IssuedAt:  jwt.NewNumericDate(time.Now().Add(-2 * time.Hour)),
		},
	}
	token := createTestToken(jwtConfig.Secret, claims)

	req := httptest.NewRequest(http.MethodGet, "/", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	handler := middleware.Auth(jwtConfig)(func(c echo.Context) error {
		return c.String(http.StatusOK, "success")
	})

	err := handler(c)

	require.Error(t, err)
	httpErr, ok := err.(*echo.HTTPError)
	require.True(t, ok)
	assert.Equal(t, http.StatusUnauthorized, httpErr.Code)
}

func TestAuth_InvalidSignature(t *testing.T) {
	e := echo.New()
	jwtConfig := config.JWTConfig{
		Secret: "correct-secret",
	}

	claims := &middleware.JWTClaims{
		UserID: "user-123",
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),
		},
	}
	token := createTestToken("wrong-secret", claims) // Wrong secret

	req := httptest.NewRequest(http.MethodGet, "/", nil)
	req.Header.Set("Authorization", "Bearer "+token)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	handler := middleware.Auth(jwtConfig)(func(c echo.Context) error {
		return c.String(http.StatusOK, "success")
	})

	err := handler(c)

	require.Error(t, err)
	httpErr, ok := err.(*echo.HTTPError)
	require.True(t, ok)
	assert.Equal(t, http.StatusUnauthorized, httpErr.Code)
}

// =============================================================================
// Context Helper Functions Tests
//
// Tests for helper functions that extract user information from the Echo
// request context after successful JWT authentication.
// =============================================================================

// TestGetUserID verifies user ID extraction from context.
func TestGetUserID(t *testing.T) {
	t.Run("returns user ID from context", func(t *testing.T) {
		e := echo.New()
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)
		c.Set("user_id", "user-123")

		userID := middleware.GetUserID(c)

		assert.Equal(t, "user-123", userID)
	})

	t.Run("returns empty string when not set", func(t *testing.T) {
		e := echo.New()
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)

		userID := middleware.GetUserID(c)

		assert.Equal(t, "", userID)
	})

	t.Run("returns empty string for wrong type", func(t *testing.T) {
		e := echo.New()
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)
		c.Set("user_id", 123) // Wrong type

		userID := middleware.GetUserID(c)

		assert.Equal(t, "", userID)
	})
}

func TestGetUserEmail(t *testing.T) {
	t.Run("returns email from context", func(t *testing.T) {
		e := echo.New()
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)
		c.Set("email", "test@example.com")

		email := middleware.GetUserEmail(c)

		assert.Equal(t, "test@example.com", email)
	})

	t.Run("returns empty string when not set", func(t *testing.T) {
		e := echo.New()
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)

		email := middleware.GetUserEmail(c)

		assert.Equal(t, "", email)
	})
}

func TestGetUserRole(t *testing.T) {
	t.Run("returns role from context", func(t *testing.T) {
		e := echo.New()
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)
		c.Set("role", "admin")

		role := middleware.GetUserRole(c)

		assert.Equal(t, "admin", role)
	})

	t.Run("returns empty string when not set", func(t *testing.T) {
		e := echo.New()
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)

		role := middleware.GetUserRole(c)

		assert.Equal(t, "", role)
	})
}

// =============================================================================
// RequireRole Middleware Tests
// =============================================================================

func TestRequireRole_Authorized(t *testing.T) {
	tests := []struct {
		name          string
		userRole      string
		requiredRoles []string
	}{
		{
			name:          "single role match",
			userRole:      "admin",
			requiredRoles: []string{"admin"},
		},
		{
			name:          "multiple roles with match",
			userRole:      "editor",
			requiredRoles: []string{"admin", "editor", "viewer"},
		},
		{
			name:          "first role matches",
			userRole:      "admin",
			requiredRoles: []string{"admin", "superadmin"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			req := httptest.NewRequest(http.MethodGet, "/", nil)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)
			c.Set("role", tt.userRole)

			handler := middleware.RequireRole(tt.requiredRoles...)(func(c echo.Context) error {
				return c.String(http.StatusOK, "success")
			})

			err := handler(c)

			assert.NoError(t, err)
			assert.Equal(t, http.StatusOK, rec.Code)
		})
	}
}

func TestRequireRole_Forbidden(t *testing.T) {
	tests := []struct {
		name          string
		userRole      string
		requiredRoles []string
	}{
		{
			name:          "role not in list",
			userRole:      "viewer",
			requiredRoles: []string{"admin", "editor"},
		},
		{
			name:          "empty user role",
			userRole:      "",
			requiredRoles: []string{"admin"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			req := httptest.NewRequest(http.MethodGet, "/", nil)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)
			c.Set("role", tt.userRole)

			handler := middleware.RequireRole(tt.requiredRoles...)(func(c echo.Context) error {
				return c.String(http.StatusOK, "success")
			})

			err := handler(c)

			require.Error(t, err)
			httpErr, ok := err.(*echo.HTTPError)
			require.True(t, ok)
			assert.Equal(t, http.StatusForbidden, httpErr.Code)
			assert.Contains(t, httpErr.Message, "insufficient permissions")
		})
	}
}

// =============================================================================
// Rate Limit Middleware Tests
// =============================================================================

func TestRateLimit(t *testing.T) {
	t.Run("allows requests within limit", func(t *testing.T) {
		e := echo.New()
		cfg := config.RateLimitConfig{
			Requests: 10,
			Window:   time.Minute,
		}

		handler := middleware.RateLimit(cfg)(func(c echo.Context) error {
			return c.String(http.StatusOK, "success")
		})

		// Make 10 requests (should all succeed)
		for i := 0; i < 10; i++ {
			req := httptest.NewRequest(http.MethodGet, "/", nil)
			req.Header.Set("X-Real-IP", "192.168.1.1")
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			err := handler(c)
			assert.NoError(t, err)
			assert.Equal(t, http.StatusOK, rec.Code)
		}
	})

	t.Run("blocks requests exceeding limit", func(t *testing.T) {
		e := echo.New()
		cfg := config.RateLimitConfig{
			Requests: 5,
			Window:   time.Minute,
		}

		handler := middleware.RateLimit(cfg)(func(c echo.Context) error {
			return c.String(http.StatusOK, "success")
		})

		// Make 6 requests (6th should fail)
		for i := 0; i < 6; i++ {
			req := httptest.NewRequest(http.MethodGet, "/", nil)
			req.Header.Set("X-Real-IP", "192.168.1.2")
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			err := handler(c)

			if i < 5 {
				assert.NoError(t, err)
			} else {
				require.Error(t, err)
				httpErr, ok := err.(*echo.HTTPError)
				require.True(t, ok)
				assert.Equal(t, http.StatusTooManyRequests, httpErr.Code)
			}
		}
	})

	t.Run("tracks different clients separately", func(t *testing.T) {
		e := echo.New()
		cfg := config.RateLimitConfig{
			Requests: 5,
			Window:   time.Minute,
		}

		handler := middleware.RateLimit(cfg)(func(c echo.Context) error {
			return c.String(http.StatusOK, "success")
		})

		// Make 5 requests from client 1
		for i := 0; i < 5; i++ {
			req := httptest.NewRequest(http.MethodGet, "/", nil)
			req.Header.Set("X-Real-IP", "192.168.1.10")
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			err := handler(c)
			assert.NoError(t, err)
		}

		// Client 2 should still be able to make requests
		for i := 0; i < 5; i++ {
			req := httptest.NewRequest(http.MethodGet, "/", nil)
			req.Header.Set("X-Real-IP", "192.168.1.20")
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			err := handler(c)
			assert.NoError(t, err)
		}
	})
}

// =============================================================================
// JWTClaims Tests
// =============================================================================

func TestJWTClaims(t *testing.T) {
	t.Run("claims contain expected fields", func(t *testing.T) {
		claims := &middleware.JWTClaims{
			UserID: "user-123",
			Email:  "test@example.com",
			Role:   "admin",
			RegisteredClaims: jwt.RegisteredClaims{
				Subject:   "user-123",
				ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),
				IssuedAt:  jwt.NewNumericDate(time.Now()),
				Issuer:    "order-service",
			},
		}

		assert.Equal(t, "user-123", claims.UserID)
		assert.Equal(t, "test@example.com", claims.Email)
		assert.Equal(t, "admin", claims.Role)
		assert.Equal(t, "user-123", claims.Subject)
		assert.Equal(t, "order-service", claims.Issuer)
	})
}

// =============================================================================
// Benchmark Tests
// =============================================================================

func BenchmarkAuth(b *testing.B) {
	e := echo.New()
	jwtConfig := config.JWTConfig{
		Secret: "test-secret-key",
	}

	claims := &middleware.JWTClaims{
		UserID: "user-123",
		Email:  "test@example.com",
		Role:   "admin",
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(time.Hour)),
		},
	}
	token := createTestToken(jwtConfig.Secret, claims)

	handler := middleware.Auth(jwtConfig)(func(c echo.Context) error {
		return nil
	})

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		req.Header.Set("Authorization", "Bearer "+token)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)
		_ = handler(c)
	}
}

func BenchmarkRateLimit(b *testing.B) {
	e := echo.New()
	cfg := config.RateLimitConfig{
		Requests: 1000000, // High limit for benchmark
		Window:   time.Minute,
	}

	handler := middleware.RateLimit(cfg)(func(c echo.Context) error {
		return nil
	})

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		req := httptest.NewRequest(http.MethodGet, "/", nil)
		req.Header.Set("X-Real-IP", "192.168.1.1")
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)
		_ = handler(c)
	}
}
