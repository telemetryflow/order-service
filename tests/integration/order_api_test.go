// Package tests provides integration tests for order-service API.
//
// Generated by TelemetryFlow RESTful API Generator
// Copyright (c) 2024-2026 DevOpsCorner Indonesia. All rights reserved.
package tests

import (
	"bytes"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/google/uuid"
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// =============================================================================
// Order API Endpoint Tests
// =============================================================================

func TestOrderAPIEndpoints(t *testing.T) {
	skipInShortMode(t)

	e := echo.New()

	// In-memory storage for testing
	orders := make(map[string]map[string]interface{})

	// Setup order endpoints with correct naming conventions
	api := e.Group("/api/v1")

	// POST /orders - Create order
	api.POST("/orders", func(c echo.Context) error {
		var order map[string]interface{}
		if err := c.Bind(&order); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}
		id := uuid.New().String()
		order["id"] = id
		orders[id] = order
		return c.JSON(http.StatusCreated, order)
	})

	// GET /orders - List orders
	api.GET("/orders", func(c echo.Context) error {
		data := make([]interface{}, 0, len(orders))
		for _, o := range orders {
			data = append(data, o)
		}
		return c.JSON(http.StatusOK, map[string]interface{}{
			"data":   data,
			"total":  len(orders),
			"offset": 0,
			"limit":  10,
		})
	})

	// GET /orders/:id - Get order by ID
	api.GET("/orders/:id", func(c echo.Context) error {
		id := c.Param("id")
		order, exists := orders[id]
		if !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Order not found")
		}
		return c.JSON(http.StatusOK, order)
	})

	// PUT /orders/:id - Update order
	api.PUT("/orders/:id", func(c echo.Context) error {
		id := c.Param("id")
		if _, exists := orders[id]; !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Order not found")
		}
		var order map[string]interface{}
		if err := c.Bind(&order); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}
		order["id"] = id
		orders[id] = order
		return c.JSON(http.StatusOK, order)
	})

	// DELETE /orders/:id - Delete order
	api.DELETE("/orders/:id", func(c echo.Context) error {
		id := c.Param("id")
		if _, exists := orders[id]; !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Order not found")
		}
		delete(orders, id)
		return c.NoContent(http.StatusNoContent)
	})

	var createdOrderID string

	t.Run("POST /orders - should create order", func(t *testing.T) {
		body := map[string]interface{}{
			"customer_id": uuid.New().String(),
			"total":       99.99,
			"status":      "pending",
		}
		jsonBody, _ := json.Marshal(body)

		req := httptest.NewRequest(http.MethodPost, "/api/v1/orders", bytes.NewBuffer(jsonBody))
		req.Header.Set("Content-Type", "application/json")
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		require.Equal(t, http.StatusCreated, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.NotEmpty(t, response["id"])
		createdOrderID = response["id"].(string)
	})

	t.Run("GET /orders - should list orders", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/api/v1/orders", nil)
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Contains(t, response, "data")
		assert.Contains(t, response, "total")
	})

	t.Run("GET /orders/:id - should get order by ID", func(t *testing.T) {
		require.NotEmpty(t, createdOrderID)

		req := httptest.NewRequest(http.MethodGet, "/api/v1/orders/"+createdOrderID, nil)
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Equal(t, createdOrderID, response["id"])
	})

	t.Run("PUT /orders/:id - should update order", func(t *testing.T) {
		require.NotEmpty(t, createdOrderID)

		body := map[string]interface{}{
			"customer_id": uuid.New().String(),
			"total":       149.99,
			"status":      "confirmed",
		}
		jsonBody, _ := json.Marshal(body)

		req := httptest.NewRequest(http.MethodPut, "/api/v1/orders/"+createdOrderID, bytes.NewBuffer(jsonBody))
		req.Header.Set("Content-Type", "application/json")
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Equal(t, "confirmed", response["status"])
	})

	t.Run("DELETE /orders/:id - should delete order", func(t *testing.T) {
		require.NotEmpty(t, createdOrderID)

		req := httptest.NewRequest(http.MethodDelete, "/api/v1/orders/"+createdOrderID, nil)
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		assert.Equal(t, http.StatusNoContent, rec.Code)
	})

	t.Run("GET /orders/:id - should return 404 for deleted order", func(t *testing.T) {
		require.NotEmpty(t, createdOrderID)

		req := httptest.NewRequest(http.MethodGet, "/api/v1/orders/"+createdOrderID, nil)
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		assert.Equal(t, http.StatusNotFound, rec.Code)
	})
}

// =============================================================================
// Order Items API Endpoint Tests (kebab-case: /order-items)
// =============================================================================

func TestOrderItemsAPIEndpoints(t *testing.T) {
	skipInShortMode(t)

	e := echo.New()

	// In-memory storage for testing
	orderItems := make(map[string]map[string]interface{})

	// Setup order-items endpoints with correct kebab-case naming
	api := e.Group("/api/v1")

	// POST /order-items - Create order item
	api.POST("/order-items", func(c echo.Context) error {
		var item map[string]interface{}
		if err := c.Bind(&item); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}
		id := uuid.New().String()
		item["id"] = id
		orderItems[id] = item
		return c.JSON(http.StatusCreated, item)
	})

	// GET /order-items - List order items
	api.GET("/order-items", func(c echo.Context) error {
		data := make([]interface{}, 0, len(orderItems))
		for _, item := range orderItems {
			data = append(data, item)
		}
		return c.JSON(http.StatusOK, map[string]interface{}{
			"data":   data,
			"total":  len(orderItems),
			"offset": 0,
			"limit":  10,
		})
	})

	// GET /order-items/:id - Get order item by ID
	api.GET("/order-items/:id", func(c echo.Context) error {
		id := c.Param("id")
		item, exists := orderItems[id]
		if !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Order item not found")
		}
		return c.JSON(http.StatusOK, item)
	})

	// PUT /order-items/:id - Update order item
	api.PUT("/order-items/:id", func(c echo.Context) error {
		id := c.Param("id")
		if _, exists := orderItems[id]; !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Order item not found")
		}
		var item map[string]interface{}
		if err := c.Bind(&item); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, "Invalid request body")
		}
		item["id"] = id
		orderItems[id] = item
		return c.JSON(http.StatusOK, item)
	})

	// DELETE /order-items/:id - Delete order item
	api.DELETE("/order-items/:id", func(c echo.Context) error {
		id := c.Param("id")
		if _, exists := orderItems[id]; !exists {
			return echo.NewHTTPError(http.StatusNotFound, "Order item not found")
		}
		delete(orderItems, id)
		return c.NoContent(http.StatusNoContent)
	})

	var createdItemID string

	t.Run("POST /order-items - should create order item", func(t *testing.T) {
		body := map[string]interface{}{
			"order_id":   uuid.New().String(),
			"product_id": uuid.New().String(),
			"quantity":   2,
			"price":      29.99,
		}
		jsonBody, _ := json.Marshal(body)

		req := httptest.NewRequest(http.MethodPost, "/api/v1/order-items", bytes.NewBuffer(jsonBody))
		req.Header.Set("Content-Type", "application/json")
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		require.Equal(t, http.StatusCreated, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.NotEmpty(t, response["id"])
		createdItemID = response["id"].(string)
	})

	t.Run("GET /order-items - should list order items", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, "/api/v1/order-items", nil)
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Contains(t, response, "data")
		assert.Contains(t, response, "total")
	})

	t.Run("GET /order-items/:id - should get order item by ID", func(t *testing.T) {
		require.NotEmpty(t, createdItemID)

		req := httptest.NewRequest(http.MethodGet, "/api/v1/order-items/"+createdItemID, nil)
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Equal(t, createdItemID, response["id"])
	})

	t.Run("PUT /order-items/:id - should update order item", func(t *testing.T) {
		require.NotEmpty(t, createdItemID)

		body := map[string]interface{}{
			"order_id":   uuid.New().String(),
			"product_id": uuid.New().String(),
			"quantity":   5,
			"price":      24.99,
		}
		jsonBody, _ := json.Marshal(body)

		req := httptest.NewRequest(http.MethodPut, "/api/v1/order-items/"+createdItemID, bytes.NewBuffer(jsonBody))
		req.Header.Set("Content-Type", "application/json")
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		require.Equal(t, http.StatusOK, rec.Code)

		var response map[string]interface{}
		err := json.Unmarshal(rec.Body.Bytes(), &response)
		require.NoError(t, err)
		assert.Equal(t, float64(5), response["quantity"])
	})

	t.Run("DELETE /order-items/:id - should delete order item", func(t *testing.T) {
		require.NotEmpty(t, createdItemID)

		req := httptest.NewRequest(http.MethodDelete, "/api/v1/order-items/"+createdItemID, nil)
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		assert.Equal(t, http.StatusNoContent, rec.Code)
	})

	t.Run("GET /order-items/:id - should return 404 for deleted item", func(t *testing.T) {
		require.NotEmpty(t, createdItemID)

		req := httptest.NewRequest(http.MethodGet, "/api/v1/order-items/"+createdItemID, nil)
		rec := httptest.NewRecorder()

		e.ServeHTTP(rec, req)

		assert.Equal(t, http.StatusNotFound, rec.Code)
	})
}

// =============================================================================
// API Naming Convention Tests
// =============================================================================

func TestAPINamingConventions(t *testing.T) {
	skipInShortMode(t)

	t.Run("order endpoints should use plural noun 'orders'", func(t *testing.T) {
		// Verify the endpoint path follows REST conventions
		expectedPath := "/api/v1/orders"
		assert.Contains(t, expectedPath, "orders")
		assert.NotContains(t, expectedPath, "order/")
	})

	t.Run("order-items endpoints should use kebab-case", func(t *testing.T) {
		// Verify the endpoint path uses kebab-case for multi-word resources
		expectedPath := "/api/v1/order-items"
		assert.Contains(t, expectedPath, "order-items")
		assert.NotContains(t, expectedPath, "orderitems")
		assert.NotContains(t, expectedPath, "order_items")
	})

	t.Run("JSON response fields should use snake_case", func(t *testing.T) {
		// Verify JSON field naming conventions
		response := map[string]interface{}{
			"id":          uuid.New().String(),
			"customer_id": uuid.New().String(),
			"order_id":    uuid.New().String(),
			"product_id":  uuid.New().String(),
			"created_at":  "2024-01-01T00:00:00Z",
			"updated_at":  "2024-01-01T00:00:00Z",
		}

		// Verify all keys use snake_case
		for key := range response {
			assert.NotContains(t, key, "-", "JSON key should not contain hyphens: %s", key)
			// snake_case uses underscores for word separation
			if len(key) > 2 {
				assert.Regexp(t, `^[a-z][a-z0-9_]*$`, key, "JSON key should be snake_case: %s", key)
			}
		}
	})
}
